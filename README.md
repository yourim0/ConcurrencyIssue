## 동시성이슈 해결방안
- 실패 원인 : 레이스 컨디션 발생. 둘 이상의 thread가 공유데이터에 엑세스할 수 있고 동시에 변경을 하려고 할 때 발생한다.
- 해결 방안 : 데이터에 한개의 쓰레드만 접근이 가능하도록 하면 된다.

  **1. synchronized 사용**
    - @Transactional과 동시에 사용했을 때 테스트 실패 원인 : Transactional 어노테이션을 적용하면 만든 클래스를 래핑한 클래스를 새로 만들어서 실행하게 된다.
    - Transaction을 시작 한 후에 메서드를 호출하고, 메서드 실행이 종료가 되면 트랜젝션을 종료하게 된다.
    - 트랜젝션 종료시점에 데이터베이스에 업데이트를 하는데 메서드 완료 후 실제 데이터베이스가 업데이트 되기 전에 다른 스레드가 메서드를 호출할 수 있게된다.
    - 다른 스레드는 갱신 전 값을 가져가 동일한 문제가 발생하게 된다.
  -> @Transactional 제거한다.

    - **synchronized 사용했을 때의 문제점** : 각 프로세스안에서만 적용되기 때문에 1개의 서버에서 갱신중인 시점에 다른 서버에서 갱신되지 않은 데이터를 가져갈 수 있다.
  
    - @Transactional은 주로 데이터베이스의 트렌잭션과 관련된 동시성을 제어하기 위해 사용되며, 데이터베이스 레벨에서 일관성을 유지하는데에 도움이 된다.
    - synchronized는 자바 내부의 동기화 메커니즘으로, 메소드나 코드 블록을 한 시점에 하나의 스레드만 접근할 수 있도록 제한하여 동시성 문제를 해결하고자 할 때 사용된다.


  **2. Database 사용**
  1. PessimisticLock
     - 실제로 데이터에 Lock을 걸어서 정합성을 맞추는 방법. exclusive lock을 걸게되면 다른 트랜잭션에서는 lock 이 해제되기 전 데이터를 가져갈 수 없다. 데드락 주의.
     - 장점 : 충돌이 빈번하게 일어날 시 optimisticlock보다 성능이 좋다. 락을 통해 업데이트를 제어하기 때문에 데이터 정합성 보장.
     - 단점 : 별도의 락을 잡기때문에 성능 저하가 있을 수 있다.

  2. OptimisticLock
     - 실제로 락을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법.
     - 장점 : 별도의 락을 잡지 않기 때문에 pessmisiticlock보다 성능상 이점이 있다.
     - 단점 : 업데이트에 실패했을 때 개발자가 재 시도 로직을 직접 적어주어야 한다.

  3. NamedLock
     - 이름을 가진 metadata Locking. 이름을 가진 lock을 획득한 후 해제될때까지 다른 세션은 이 lock을 획득할 수 없다.
     - 단점 : 구현방법이 어려움, 트랜젝션이 종료될 때 lock이 자동해제되지 않아 별도로 명령어로 해제를 수행해주거나 선점시간이 끝나야한다.
     - 주로 분산망 구현 시 사용, timeout 구현가능

